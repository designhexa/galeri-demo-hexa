
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://svqjeqngyindshuxjurp.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN2cWplcW5neWluZHNodXhqdXJwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQzNTcwMjgsImV4cCI6MjA1OTkzMzAyOH0.IAjaLkfO-wzYh9LzfF6tkYS2VPLHVkbewut2pu0Y67E";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true
  }
});

// Add debug helper that logs all auth state changes with more detailed information
supabase.auth.onAuthStateChange((event, session) => {
  console.log("[Supabase Debug] Auth state changed:", event);
  if (session?.user) {
    console.log("[Supabase Debug] User ID:", session.user.id);
    console.log("[Supabase Debug] User email:", session.user.email);
    console.log("[Supabase Debug] User metadata:", session.user.user_metadata);
  } else {
    console.log("[Supabase Debug] No active session");
  }
});

// Storage bucket names and folder paths
export const STORAGE_BUCKETS = {
  PROJECT_IMAGES: 'project-images',
  SECTION_BACKGROUNDS: 'section-backgrounds'
};

export const STORAGE_FOLDERS = {
  PROJECT_COVERS: 'covers',
  PROJECT_SCREENSHOTS: 'screenshots'
};

// Additional debug function to check profile data
export const checkProfileData = async (userId: string) => {
  const { data, error } = await supabase
    .from('profiles')
    .select('*')
    .eq('id', userId)
    .single();
    
  if (error) {
    console.error("[Profile Debug] Error fetching profile:", error);
    return null;
  }
  
  console.log("[Profile Debug] Profile data:", data);
  return data;
};

// Helper function to get a public URL for a file in storage
export const getPublicUrl = (bucket: string, path: string): string => {
  const { data } = supabase.storage.from(bucket).getPublicUrl(path);
  return data.publicUrl;
};

// Enhanced helper function to upload a file to storage with better error handling
export const uploadFile = async (
  bucket: string, 
  path: string, 
  file: File,
  onProgress?: (progress: number) => void
): Promise<{ url: string; path: string } | null> => {
  try {
    // Check if the user is authenticated
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      console.error('[Storage Debug] User is not authenticated');
      throw new Error('User is not authenticated');
    }

    console.log('[Storage Debug] Starting upload to bucket:', bucket, 'path:', path);
    console.log('[Storage Debug] User ID:', session.user.id);
    
    // Simple progress tracking
    if (onProgress) {
      onProgress(10);
    }
    
    // Upload file with cacheControl and upsert options
    const { data, error } = await supabase.storage
      .from(bucket)
      .upload(path, file, {
        cacheControl: '3600',
        upsert: true
      });

    if (onProgress) {
      onProgress(100);
    }

    if (error) {
      console.error('[Storage Debug] Upload error:', error);
      throw error;
    }

    if (!data) {
      throw new Error('Upload returned no data');
    }

    const url = getPublicUrl(bucket, data.path);
    console.log('[Storage Debug] File uploaded successfully:', { path: data.path, url });
    
    return { url, path: data.path };
  } catch (error) {
    console.error('[Storage Debug] Error in uploadFile:', error);
    return null;
  }
};

// Enhanced helper function to delete a file from storage with better error handling
export const deleteFile = async (bucket: string, path: string): Promise<boolean> => {
  try {
    // Check if the user is authenticated
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      console.error('[Storage Debug] User is not authenticated for deletion');
      throw new Error('User is not authenticated');
    }

    console.log('[Storage Debug] Attempting to delete file from bucket:', bucket, 'path:', path);
    console.log('[Storage Debug] User ID:', session.user.id);
    
    // Check if user is admin for logging purposes
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', session.user.id)
      .maybeSingle();
      
    if (profile && profile.role === 'admin') {
      console.log('[Storage Debug] Admin user is deleting file');
    }
    
    const { error } = await supabase.storage
      .from(bucket)
      .remove([path]);

    if (error) {
      console.error('[Storage Debug] Delete error:', error);
      throw error;
    }

    console.log('[Storage Debug] File deleted successfully:', path);
    return true;
  } catch (error) {
    console.error('[Storage Debug] Error in deleteFile:', error);
    return false;
  }
};

// Project-specific database operations with improved admin handling
export const projectOperations = {
  // Fetch all projects
  fetchProjects: async () => {
    const { data, error } = await supabase
      .from('projects')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) {
      console.error('[Project Debug] Error fetching projects:', error);
      throw error;
    }
    
    console.log('[Project Debug] Successfully fetched projects:', data ? data.length : 0);
    return data;
  },
  
  // Add a new project
  addProject: async (projectData: any, userId: string) => {
    try {
      console.log('[Project Debug] Adding project with user ID:', userId);
      console.log('[Project Debug] Project data:', projectData);
      
      const { data, error } = await supabase
        .from('projects')
        .insert({
          ...projectData,
          user_id: userId
        })
        .select()
        .single();
        
      if (error) {
        console.error('[Project Debug] Error adding project:', error);
        throw error;
      }
      
      console.log('[Project Debug] Project added successfully:', data);
      return data;
    } catch (error) {
      console.error('[Project Debug] Exception in addProject:', error);
      throw error;
    }
  },
  
  // Update an existing project with enhanced admin capability
  updateProject: async (projectId: string, projectData: any, userId: string) => {
    try {
      console.log('[Project Debug] Updating project with ID:', projectId, 'User ID:', userId);
      console.log('[Project Debug] Update data:', projectData);
      
      // Check if user is admin
      const { data: profileData } = await supabase
        .from('profiles')
        .select('role')
        .eq('id', userId)
        .maybeSingle();
      
      console.log('[Project Debug] User role for update:', profileData?.role);
      
      const { data, error } = await supabase
        .from('projects')
        .update({
          ...projectData,
          updated_at: new Date().toISOString()
        })
        .eq('id', projectId)
        .select()
        .single();
        
      if (error) {
        console.error('[Project Debug] Error updating project:', error);
        throw error;
      }
      
      console.log('[Project Debug] Project updated successfully:', data);
      return data;
    } catch (error) {
      console.error('[Project Debug] Exception in updateProject:', error);
      throw error;
    }
  },
  
  // Delete a project with enhanced admin capability
  deleteProject: async (projectId: string, userId: string) => {
    try {
      console.log('[Project Debug] Deleting project with ID:', projectId, 'User ID:', userId);
      
      // Check if user is admin for logging
      const { data: profileData } = await supabase
        .from('profiles')
        .select('role')
        .eq('id', userId)
        .maybeSingle();
      
      console.log('[Project Debug] User role for deletion:', profileData?.role);
      
      // First, get the project to access its images
      const { data: project, error: fetchError } = await supabase
        .from('projects')
        .select('cover_image, screenshots')
        .eq('id', projectId)
        .maybeSingle();
      
      if (fetchError) {
        console.error('[Project Debug] Error fetching project for deletion:', fetchError);
      } else if (project) {
        // Delete cover image if it exists and is from Supabase
        if (project.cover_image && project.cover_image.includes('project-images')) {
          try {
            const coverPath = project.cover_image.split('/project-images/')[1];
            if (coverPath) {
              await deleteFile('project-images', coverPath).catch(err => 
                console.error('[Project Debug] Error deleting cover image:', err)
              );
            }
          } catch (err) {
            console.error('[Project Debug] Error parsing cover image path:', err);
          }
        }
        
        // Delete all screenshots if they exist and are from Supabase
        if (project.screenshots && project.screenshots.length > 0) {
          for (const screenshot of project.screenshots) {
            if (screenshot && screenshot.includes('project-images')) {
              try {
                const screenshotPath = screenshot.split('/project-images/')[1];
                if (screenshotPath) {
                  await deleteFile('project-images', screenshotPath).catch(err => 
                    console.error('[Project Debug] Error deleting screenshot:', err)
                  );
                }
              } catch (err) {
                console.error('[Project Debug] Error parsing screenshot path:', err);
              }
            }
          }
        }
      }
      
      // Now delete the project
      const { error } = await supabase
        .from('projects')
        .delete()
        .eq('id', projectId);
        
      if (error) {
        console.error('[Project Debug] Error deleting project from database:', error);
        throw error;
      }
      
      console.log('[Project Debug] Project deleted successfully:', projectId);
      return true;
    } catch (error) {
      console.error('[Project Debug] Exception in deleteProject:', error);
      throw error;
    }
  }
};

// Check if the storage buckets exist, create them if they don't
export const ensureStorageBuckets = async () => {
  try {
    console.log('[Storage Debug] Checking for required storage buckets');
    
    // Check if the user is authenticated
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      console.log('[Storage Debug] User is not authenticated, skipping bucket check');
      return;
    }
    
    const { data: buckets, error } = await supabase.storage.listBuckets();
    
    if (error) {
      console.error('[Storage Debug] Error listing buckets:', error);
      return;
    }
    
    const requiredBuckets = [STORAGE_BUCKETS.PROJECT_IMAGES, STORAGE_BUCKETS.SECTION_BACKGROUNDS];
    const existingBuckets = buckets.map(b => b.name);
    
    for (const bucket of requiredBuckets) {
      if (!existingBuckets.includes(bucket)) {
        console.log(`[Storage Debug] Bucket ${bucket} is configured but not accessible`);
      } else {
        console.log(`[Storage Debug] Bucket ${bucket} exists and is accessible`);
        
        // Check folder structure in buckets
        if (bucket === STORAGE_BUCKETS.PROJECT_IMAGES) {
          const { data: files, error: listError } = await supabase.storage
            .from(bucket)
            .list();
            
          if (listError) {
            console.error(`[Storage Debug] Error checking folder structure in ${bucket}:`, listError);
          } else {
            console.log(`[Storage Debug] Files in ${bucket}:`, files);
            
            // Check if required folders exist
            const folders = [STORAGE_FOLDERS.PROJECT_COVERS, STORAGE_FOLDERS.PROJECT_SCREENSHOTS];
            
            for (const folder of folders) {
              if (!files.some(f => f.name === `${folder}/`)) {
                console.log(`[Storage Debug] Folder ${folder} not found, attempting to create a placeholder`);
                try {
                  // The folder will be created automatically when uploading files, but we can't
                  // directly create empty folders through the API without creating a placeholder file
                  const testContent = new Blob([''], { type: 'text/plain' });
                  const testFilePath = `${folder}/.placeholder`;
                  
                  await supabase.storage
                    .from(bucket)
                    .upload(testFilePath, testContent, { upsert: true });
                    
                  console.log(`[Storage Debug] Created placeholder for folder ${folder}`);
                } catch (folderError) {
                  console.error(`[Storage Debug] Error creating placeholder for ${folder}:`, folderError);
                }
              } else {
                console.log(`[Storage Debug] Folder ${folder} exists in bucket ${bucket}`);
              }
            }
          }
        }
      }
    }
  } catch (error) {
    console.error('[Storage Debug] Exception in ensureStorageBuckets:', error);
  }
};

// Initialize bucket check when the client is imported
ensureStorageBuckets();
